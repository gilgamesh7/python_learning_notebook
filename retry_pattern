# Retry Pattern: The Secret to Resilient Python Code
# https://youtu.be/43vH_lnM7x0?si=Py0DB_RErKAdtTEA

import random
import httpx

from typing import TypedDict, List, Callable

class ChuckNorrisJoke(TypedDict):
    categories: List[str]
    created_at: str
    icon_url: str
    id: str
    updated_at: str
    url: str
    value: str

def retry[T](operation: Callable[[], T], retries: int = 3, delay: float = 1.0, backoff: float = 1.0) -> T:
    """ Retry an operation a number of times with a delay """

    for attempt in range(1, retries+1):
        try:
            return operation()
        except Exception as e:
            print(f"Attempt {attempt} failed: {e}")
            if attempt == retries:
                raise
            import time
            sleep_time: float = delay * (backoff ** (attempt - 1))
            print(f"Retrying in {sleep_time:.1f} seconds...")
            time.sleep(sleep_time)
    raise Exception(f"Operation failed after {retries} attempts")


def fetch_joke()-> str:
    """ Fecth a Chuck Norris Joke froma public API """

    # randomly raise errors to simulate a flaky API
    if random.choice([0, 1, 2, 3, 4]) == 0:
        raise httpx.HTTPError("Chuck Norris is not happy - Simulated API failure")

    with httpx.Client() as client:
        response = client.get("https://api.chucknorris.io/jokes/random")
        response.raise_for_status()
        data : ChuckNorrisJoke = response.json()
        return data["value"]

def main()-> None:
    joke = retry(fetch_joke, retries=5, delay=2.0)
    print(fetch_joke())

if __name__ == "__main__":
    main()